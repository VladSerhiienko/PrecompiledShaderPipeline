// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CSO_CSO_H_
#define FLATBUFFERS_GENERATED_CSO_CSO_H_

#include "flatbuffers/flatbuffers.h"

namespace cso {

struct HashedString;

struct HashedBuffer;

struct CompiledShaderInfo;

struct CompiledShader;

struct CompiledShaderCollection;

enum EVersion {
  EVersion_Value = 0,
  EVersion_MIN = EVersion_Value,
  EVersion_MAX = EVersion_Value
};

inline const EVersion (&EnumValuesEVersion())[1] {
  static const EVersion values[] = {
    EVersion_Value
  };
  return values;
}

inline const char * const *EnumNamesEVersion() {
  static const char * const names[] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVersion(EVersion e) {
  if (e < EVersion_Value || e > EVersion_Value) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEVersion()[index];
}

enum EIR {
  EIR_SPIRV = 0,
  EIR_MIN = EIR_SPIRV,
  EIR_MAX = EIR_SPIRV
};

inline const EIR (&EnumValuesEIR())[1] {
  static const EIR values[] = {
    EIR_SPIRV
  };
  return values;
}

inline const char * const *EnumNamesEIR() {
  static const char * const names[] = {
    "SPIRV",
    nullptr
  };
  return names;
}

inline const char *EnumNameEIR(EIR e) {
  if (e < EIR_SPIRV || e > EIR_SPIRV) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEIR()[index];
}

enum EShader {
  EShader_Vert = 0,
  EShader_Frag = 1,
  EShader_Comp = 2,
  EShader_Geom = 3,
  EShader_Tesc = 4,
  EShader_Tese = 5,
  EShader_MIN = EShader_Vert,
  EShader_MAX = EShader_Tese
};

inline const EShader (&EnumValuesEShader())[6] {
  static const EShader values[] = {
    EShader_Vert,
    EShader_Frag,
    EShader_Comp,
    EShader_Geom,
    EShader_Tesc,
    EShader_Tese
  };
  return values;
}

inline const char * const *EnumNamesEShader() {
  static const char * const names[] = {
    "Vert",
    "Frag",
    "Comp",
    "Geom",
    "Tesc",
    "Tese",
    nullptr
  };
  return names;
}

inline const char *EnumNameEShader(EShader e) {
  if (e < EShader_Vert || e > EShader_Tese) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEShader()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CompiledShader FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t preprocessed_string_index_;
  uint32_t preprocessed_opt_string_index_;
  uint32_t assembly_string_index_;
  uint32_t compiled_buffer_index_;
  uint32_t crc2_;

 public:
  CompiledShader() {
    memset(static_cast<void *>(this), 0, sizeof(CompiledShader));
  }
  CompiledShader(uint32_t _preprocessed_string_index, uint32_t _preprocessed_opt_string_index, uint32_t _assembly_string_index, uint32_t _compiled_buffer_index, uint32_t _crc2)
      : preprocessed_string_index_(flatbuffers::EndianScalar(_preprocessed_string_index)),
        preprocessed_opt_string_index_(flatbuffers::EndianScalar(_preprocessed_opt_string_index)),
        assembly_string_index_(flatbuffers::EndianScalar(_assembly_string_index)),
        compiled_buffer_index_(flatbuffers::EndianScalar(_compiled_buffer_index)),
        crc2_(flatbuffers::EndianScalar(_crc2)) {
  }
  uint32_t preprocessed_string_index() const {
    return flatbuffers::EndianScalar(preprocessed_string_index_);
  }
  uint32_t preprocessed_opt_string_index() const {
    return flatbuffers::EndianScalar(preprocessed_opt_string_index_);
  }
  uint32_t assembly_string_index() const {
    return flatbuffers::EndianScalar(assembly_string_index_);
  }
  uint32_t compiled_buffer_index() const {
    return flatbuffers::EndianScalar(compiled_buffer_index_);
  }
  uint32_t crc2() const {
    return flatbuffers::EndianScalar(crc2_);
  }
};
FLATBUFFERS_STRUCT_END(CompiledShader, 20);

struct HashedString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENTS = 4,
    VT_CRC2 = 6
  };
  const flatbuffers::String *contents() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENTS);
  }
  uint32_t crc2() const {
    return GetField<uint32_t>(VT_CRC2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyString(contents()) &&
           VerifyField<uint32_t>(verifier, VT_CRC2) &&
           verifier.EndTable();
  }
};

struct HashedStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contents(flatbuffers::Offset<flatbuffers::String> contents) {
    fbb_.AddOffset(HashedString::VT_CONTENTS, contents);
  }
  void add_crc2(uint32_t crc2) {
    fbb_.AddElement<uint32_t>(HashedString::VT_CRC2, crc2, 0);
  }
  explicit HashedStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashedStringBuilder &operator=(const HashedStringBuilder &);
  flatbuffers::Offset<HashedString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashedString>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashedString> CreateHashedString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> contents = 0,
    uint32_t crc2 = 0) {
  HashedStringBuilder builder_(_fbb);
  builder_.add_crc2(crc2);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline flatbuffers::Offset<HashedString> CreateHashedStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *contents = nullptr,
    uint32_t crc2 = 0) {
  auto contents__ = contents ? _fbb.CreateString(contents) : 0;
  return cso::CreateHashedString(
      _fbb,
      contents__,
      crc2);
}

struct HashedBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENTS = 4,
    VT_CRC2 = 6
  };
  const flatbuffers::Vector<int8_t> *contents() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_CONTENTS);
  }
  uint32_t crc2() const {
    return GetField<uint32_t>(VT_CRC2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) &&
           VerifyField<uint32_t>(verifier, VT_CRC2) &&
           verifier.EndTable();
  }
};

struct HashedBufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contents(flatbuffers::Offset<flatbuffers::Vector<int8_t>> contents) {
    fbb_.AddOffset(HashedBuffer::VT_CONTENTS, contents);
  }
  void add_crc2(uint32_t crc2) {
    fbb_.AddElement<uint32_t>(HashedBuffer::VT_CRC2, crc2, 0);
  }
  explicit HashedBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashedBufferBuilder &operator=(const HashedBufferBuilder &);
  flatbuffers::Offset<HashedBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashedBuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashedBuffer> CreateHashedBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> contents = 0,
    uint32_t crc2 = 0) {
  HashedBufferBuilder builder_(_fbb);
  builder_.add_crc2(crc2);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline flatbuffers::Offset<HashedBuffer> CreateHashedBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *contents = nullptr,
    uint32_t crc2 = 0) {
  auto contents__ = contents ? _fbb.CreateVector<int8_t>(*contents) : 0;
  return cso::CreateHashedBuffer(
      _fbb,
      contents__,
      crc2);
}

struct CompiledShaderInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_SHADER = 6,
    VT_ASSET_STRING_INDEX = 8,
    VT_DEFINITIONS_STRING_INDEX = 10,
    VT_DEFINITIONS_MAP = 12,
    VT_INCLUDED_FILES_STRING_INDICES = 14
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  EShader shader() const {
    return static_cast<EShader>(GetField<uint32_t>(VT_SHADER, 0));
  }
  uint32_t asset_string_index() const {
    return GetField<uint32_t>(VT_ASSET_STRING_INDEX, 0);
  }
  uint32_t definitions_string_index() const {
    return GetField<uint32_t>(VT_DEFINITIONS_STRING_INDEX, 0);
  }
  const flatbuffers::Vector<uint32_t> *definitions_map() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DEFINITIONS_MAP);
  }
  const flatbuffers::Vector<uint32_t> *included_files_string_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INCLUDED_FILES_STRING_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_SHADER) &&
           VerifyField<uint32_t>(verifier, VT_ASSET_STRING_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_DEFINITIONS_STRING_INDEX) &&
           VerifyOffset(verifier, VT_DEFINITIONS_MAP) &&
           verifier.VerifyVector(definitions_map()) &&
           VerifyOffset(verifier, VT_INCLUDED_FILES_STRING_INDICES) &&
           verifier.VerifyVector(included_files_string_indices()) &&
           verifier.EndTable();
  }
};

struct CompiledShaderInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_INDEX, index, 0);
  }
  void add_shader(EShader shader) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_SHADER, static_cast<uint32_t>(shader), 0);
  }
  void add_asset_string_index(uint32_t asset_string_index) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_ASSET_STRING_INDEX, asset_string_index, 0);
  }
  void add_definitions_string_index(uint32_t definitions_string_index) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_DEFINITIONS_STRING_INDEX, definitions_string_index, 0);
  }
  void add_definitions_map(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> definitions_map) {
    fbb_.AddOffset(CompiledShaderInfo::VT_DEFINITIONS_MAP, definitions_map);
  }
  void add_included_files_string_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> included_files_string_indices) {
    fbb_.AddOffset(CompiledShaderInfo::VT_INCLUDED_FILES_STRING_INDICES, included_files_string_indices);
  }
  explicit CompiledShaderInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompiledShaderInfoBuilder &operator=(const CompiledShaderInfoBuilder &);
  flatbuffers::Offset<CompiledShaderInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledShaderInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledShaderInfo> CreateCompiledShaderInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    EShader shader = EShader_Vert,
    uint32_t asset_string_index = 0,
    uint32_t definitions_string_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> definitions_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> included_files_string_indices = 0) {
  CompiledShaderInfoBuilder builder_(_fbb);
  builder_.add_included_files_string_indices(included_files_string_indices);
  builder_.add_definitions_map(definitions_map);
  builder_.add_definitions_string_index(definitions_string_index);
  builder_.add_asset_string_index(asset_string_index);
  builder_.add_shader(shader);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledShaderInfo> CreateCompiledShaderInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    EShader shader = EShader_Vert,
    uint32_t asset_string_index = 0,
    uint32_t definitions_string_index = 0,
    const std::vector<uint32_t> *definitions_map = nullptr,
    const std::vector<uint32_t> *included_files_string_indices = nullptr) {
  auto definitions_map__ = definitions_map ? _fbb.CreateVector<uint32_t>(*definitions_map) : 0;
  auto included_files_string_indices__ = included_files_string_indices ? _fbb.CreateVector<uint32_t>(*included_files_string_indices) : 0;
  return cso::CreateCompiledShaderInfo(
      _fbb,
      index,
      shader,
      asset_string_index,
      definitions_string_index,
      definitions_map__,
      included_files_string_indices__);
}

struct CompiledShaderCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_COMPILED_SHADER_INFOS = 6,
    VT_COMPILED_SHADERS = 8,
    VT_HASHED_STRINGS = 10,
    VT_HASHED_BUFFERS = 12
  };
  EVersion version() const {
    return static_cast<EVersion>(GetField<uint8_t>(VT_VERSION, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>> *compiled_shader_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>> *>(VT_COMPILED_SHADER_INFOS);
  }
  const flatbuffers::Vector<const CompiledShader *> *compiled_shaders() const {
    return GetPointer<const flatbuffers::Vector<const CompiledShader *> *>(VT_COMPILED_SHADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HashedString>> *hashed_strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HashedString>> *>(VT_HASHED_STRINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HashedString>> *hashed_buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HashedString>> *>(VT_HASHED_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_COMPILED_SHADER_INFOS) &&
           verifier.VerifyVector(compiled_shader_infos()) &&
           verifier.VerifyVectorOfTables(compiled_shader_infos()) &&
           VerifyOffset(verifier, VT_COMPILED_SHADERS) &&
           verifier.VerifyVector(compiled_shaders()) &&
           VerifyOffset(verifier, VT_HASHED_STRINGS) &&
           verifier.VerifyVector(hashed_strings()) &&
           verifier.VerifyVectorOfTables(hashed_strings()) &&
           VerifyOffset(verifier, VT_HASHED_BUFFERS) &&
           verifier.VerifyVector(hashed_buffers()) &&
           verifier.VerifyVectorOfTables(hashed_buffers()) &&
           verifier.EndTable();
  }
};

struct CompiledShaderCollectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(EVersion version) {
    fbb_.AddElement<uint8_t>(CompiledShaderCollection::VT_VERSION, static_cast<uint8_t>(version), 0);
  }
  void add_compiled_shader_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>>> compiled_shader_infos) {
    fbb_.AddOffset(CompiledShaderCollection::VT_COMPILED_SHADER_INFOS, compiled_shader_infos);
  }
  void add_compiled_shaders(flatbuffers::Offset<flatbuffers::Vector<const CompiledShader *>> compiled_shaders) {
    fbb_.AddOffset(CompiledShaderCollection::VT_COMPILED_SHADERS, compiled_shaders);
  }
  void add_hashed_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HashedString>>> hashed_strings) {
    fbb_.AddOffset(CompiledShaderCollection::VT_HASHED_STRINGS, hashed_strings);
  }
  void add_hashed_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HashedString>>> hashed_buffers) {
    fbb_.AddOffset(CompiledShaderCollection::VT_HASHED_BUFFERS, hashed_buffers);
  }
  explicit CompiledShaderCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompiledShaderCollectionBuilder &operator=(const CompiledShaderCollectionBuilder &);
  flatbuffers::Offset<CompiledShaderCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledShaderCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledShaderCollection> CreateCompiledShaderCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersion version = EVersion_Value,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>>> compiled_shader_infos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const CompiledShader *>> compiled_shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HashedString>>> hashed_strings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HashedString>>> hashed_buffers = 0) {
  CompiledShaderCollectionBuilder builder_(_fbb);
  builder_.add_hashed_buffers(hashed_buffers);
  builder_.add_hashed_strings(hashed_strings);
  builder_.add_compiled_shaders(compiled_shaders);
  builder_.add_compiled_shader_infos(compiled_shader_infos);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledShaderCollection> CreateCompiledShaderCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersion version = EVersion_Value,
    const std::vector<flatbuffers::Offset<CompiledShaderInfo>> *compiled_shader_infos = nullptr,
    const std::vector<CompiledShader> *compiled_shaders = nullptr,
    const std::vector<flatbuffers::Offset<HashedString>> *hashed_strings = nullptr,
    const std::vector<flatbuffers::Offset<HashedString>> *hashed_buffers = nullptr) {
  auto compiled_shader_infos__ = compiled_shader_infos ? _fbb.CreateVector<flatbuffers::Offset<CompiledShaderInfo>>(*compiled_shader_infos) : 0;
  auto compiled_shaders__ = compiled_shaders ? _fbb.CreateVectorOfStructs<CompiledShader>(*compiled_shaders) : 0;
  auto hashed_strings__ = hashed_strings ? _fbb.CreateVector<flatbuffers::Offset<HashedString>>(*hashed_strings) : 0;
  auto hashed_buffers__ = hashed_buffers ? _fbb.CreateVector<flatbuffers::Offset<HashedString>>(*hashed_buffers) : 0;
  return cso::CreateCompiledShaderCollection(
      _fbb,
      version,
      compiled_shader_infos__,
      compiled_shaders__,
      hashed_strings__,
      hashed_buffers__);
}

inline const cso::CompiledShaderCollection *GetCompiledShaderCollection(const void *buf) {
  return flatbuffers::GetRoot<cso::CompiledShaderCollection>(buf);
}

inline const cso::CompiledShaderCollection *GetSizePrefixedCompiledShaderCollection(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cso::CompiledShaderCollection>(buf);
}

inline const char *CompiledShaderCollectionIdentifier() {
  return "CSOC";
}

inline bool CompiledShaderCollectionBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CompiledShaderCollectionIdentifier());
}

inline bool VerifyCompiledShaderCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cso::CompiledShaderCollection>(CompiledShaderCollectionIdentifier());
}

inline bool VerifySizePrefixedCompiledShaderCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cso::CompiledShaderCollection>(CompiledShaderCollectionIdentifier());
}

inline const char *CompiledShaderCollectionExtension() {
  return "csoc";
}

inline void FinishCompiledShaderCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cso::CompiledShaderCollection> root) {
  fbb.Finish(root, CompiledShaderCollectionIdentifier());
}

inline void FinishSizePrefixedCompiledShaderCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cso::CompiledShaderCollection> root) {
  fbb.FinishSizePrefixed(root, CompiledShaderCollectionIdentifier());
}

}  // namespace cso

#endif  // FLATBUFFERS_GENERATED_CSO_CSO_H_
