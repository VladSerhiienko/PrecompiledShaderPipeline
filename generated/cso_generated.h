// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CSO_CSO_H_
#define FLATBUFFERS_GENERATED_CSO_CSO_H_

#include "flatbuffers/flatbuffers.h"

namespace cso {

struct PrecompiledShader;

struct Collection;

enum EVersion {
  EVersion_Value = 0,
  EVersion_MIN = EVersion_Value,
  EVersion_MAX = EVersion_Value
};

inline const EVersion (&EnumValuesEVersion())[1] {
  static const EVersion values[] = {
    EVersion_Value
  };
  return values;
}

inline const char * const *EnumNamesEVersion() {
  static const char * const names[] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVersion(EVersion e) {
  if (e < EVersion_Value || e > EVersion_Value) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEVersion()[index];
}

enum EShaderType {
  EShaderType_Vert = 0,
  EShaderType_Frag = 1,
  EShaderType_Comp = 2,
  EShaderType_Geom = 3,
  EShaderType_Tesc = 4,
  EShaderType_Tese = 5,
  EShaderType_MIN = EShaderType_Vert,
  EShaderType_MAX = EShaderType_Tese
};

inline const EShaderType (&EnumValuesEShaderType())[6] {
  static const EShaderType values[] = {
    EShaderType_Vert,
    EShaderType_Frag,
    EShaderType_Comp,
    EShaderType_Geom,
    EShaderType_Tesc,
    EShaderType_Tese
  };
  return values;
}

inline const char * const *EnumNamesEShaderType() {
  static const char * const names[] = {
    "Vert",
    "Frag",
    "Comp",
    "Geom",
    "Tesc",
    "Tese",
    nullptr
  };
  return names;
}

inline const char *EnumNameEShaderType(EShaderType e) {
  if (e < EShaderType_Vert || e > EShaderType_Tese) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEShaderType()[index];
}

struct PrecompiledShader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSET = 4,
    VT_MACROS = 6,
    VT_SHADER_TYPE = 8,
    VT_IR = 10
  };
  const flatbuffers::String *asset() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET);
  }
  flatbuffers::String *mutable_asset() {
    return GetPointer<flatbuffers::String *>(VT_ASSET);
  }
  const flatbuffers::String *macros() const {
    return GetPointer<const flatbuffers::String *>(VT_MACROS);
  }
  flatbuffers::String *mutable_macros() {
    return GetPointer<flatbuffers::String *>(VT_MACROS);
  }
  EShaderType shader_type() const {
    return static_cast<EShaderType>(GetField<uint32_t>(VT_SHADER_TYPE, 0));
  }
  bool mutate_shader_type(EShaderType _shader_type) {
    return SetField<uint32_t>(VT_SHADER_TYPE, static_cast<uint32_t>(_shader_type), 0);
  }
  const flatbuffers::Vector<uint32_t> *IR() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_IR);
  }
  flatbuffers::Vector<uint32_t> *mutable_IR() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_IR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSET) &&
           verifier.VerifyString(asset()) &&
           VerifyOffset(verifier, VT_MACROS) &&
           verifier.VerifyString(macros()) &&
           VerifyField<uint32_t>(verifier, VT_SHADER_TYPE) &&
           VerifyOffset(verifier, VT_IR) &&
           verifier.VerifyVector(IR()) &&
           verifier.EndTable();
  }
};

struct PrecompiledShaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset(flatbuffers::Offset<flatbuffers::String> asset) {
    fbb_.AddOffset(PrecompiledShader::VT_ASSET, asset);
  }
  void add_macros(flatbuffers::Offset<flatbuffers::String> macros) {
    fbb_.AddOffset(PrecompiledShader::VT_MACROS, macros);
  }
  void add_shader_type(EShaderType shader_type) {
    fbb_.AddElement<uint32_t>(PrecompiledShader::VT_SHADER_TYPE, static_cast<uint32_t>(shader_type), 0);
  }
  void add_IR(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> IR) {
    fbb_.AddOffset(PrecompiledShader::VT_IR, IR);
  }
  explicit PrecompiledShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrecompiledShaderBuilder &operator=(const PrecompiledShaderBuilder &);
  flatbuffers::Offset<PrecompiledShader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PrecompiledShader>(end);
    return o;
  }
};

inline flatbuffers::Offset<PrecompiledShader> CreatePrecompiledShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset = 0,
    flatbuffers::Offset<flatbuffers::String> macros = 0,
    EShaderType shader_type = EShaderType_Vert,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> IR = 0) {
  PrecompiledShaderBuilder builder_(_fbb);
  builder_.add_IR(IR);
  builder_.add_shader_type(shader_type);
  builder_.add_macros(macros);
  builder_.add_asset(asset);
  return builder_.Finish();
}

inline flatbuffers::Offset<PrecompiledShader> CreatePrecompiledShaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset = nullptr,
    const char *macros = nullptr,
    EShaderType shader_type = EShaderType_Vert,
    const std::vector<uint32_t> *IR = nullptr) {
  auto asset__ = asset ? _fbb.CreateString(asset) : 0;
  auto macros__ = macros ? _fbb.CreateString(macros) : 0;
  auto IR__ = IR ? _fbb.CreateVector<uint32_t>(*IR) : 0;
  return cso::CreatePrecompiledShader(
      _fbb,
      asset__,
      macros__,
      shader_type,
      IR__);
}

struct Collection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_PRECOMPILED_SHADERS = 6
  };
  EVersion version() const {
    return static_cast<EVersion>(GetField<uint8_t>(VT_VERSION, 0));
  }
  bool mutate_version(EVersion _version) {
    return SetField<uint8_t>(VT_VERSION, static_cast<uint8_t>(_version), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PrecompiledShader>> *precompiled_shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PrecompiledShader>> *>(VT_PRECOMPILED_SHADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<PrecompiledShader>> *mutable_precompiled_shaders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<PrecompiledShader>> *>(VT_PRECOMPILED_SHADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_PRECOMPILED_SHADERS) &&
           verifier.VerifyVector(precompiled_shaders()) &&
           verifier.VerifyVectorOfTables(precompiled_shaders()) &&
           verifier.EndTable();
  }
};

struct CollectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(EVersion version) {
    fbb_.AddElement<uint8_t>(Collection::VT_VERSION, static_cast<uint8_t>(version), 0);
  }
  void add_precompiled_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PrecompiledShader>>> precompiled_shaders) {
    fbb_.AddOffset(Collection::VT_PRECOMPILED_SHADERS, precompiled_shaders);
  }
  explicit CollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CollectionBuilder &operator=(const CollectionBuilder &);
  flatbuffers::Offset<Collection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Collection>(end);
    return o;
  }
};

inline flatbuffers::Offset<Collection> CreateCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersion version = EVersion_Value,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PrecompiledShader>>> precompiled_shaders = 0) {
  CollectionBuilder builder_(_fbb);
  builder_.add_precompiled_shaders(precompiled_shaders);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Collection> CreateCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersion version = EVersion_Value,
    const std::vector<flatbuffers::Offset<PrecompiledShader>> *precompiled_shaders = nullptr) {
  auto precompiled_shaders__ = precompiled_shaders ? _fbb.CreateVector<flatbuffers::Offset<PrecompiledShader>>(*precompiled_shaders) : 0;
  return cso::CreateCollection(
      _fbb,
      version,
      precompiled_shaders__);
}

inline const cso::Collection *GetCollection(const void *buf) {
  return flatbuffers::GetRoot<cso::Collection>(buf);
}

inline const cso::Collection *GetSizePrefixedCollection(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cso::Collection>(buf);
}

inline Collection *GetMutableCollection(void *buf) {
  return flatbuffers::GetMutableRoot<Collection>(buf);
}

inline const char *CollectionIdentifier() {
  return "PSHP";
}

inline bool CollectionBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CollectionIdentifier());
}

inline bool VerifyCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cso::Collection>(CollectionIdentifier());
}

inline bool VerifySizePrefixedCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cso::Collection>(CollectionIdentifier());
}

inline const char *CollectionExtension() {
  return "pshp";
}

inline void FinishCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cso::Collection> root) {
  fbb.Finish(root, CollectionIdentifier());
}

inline void FinishSizePrefixedCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cso::Collection> root) {
  fbb.FinishSizePrefixed(root, CollectionIdentifier());
}

}  // namespace cso

#endif  // FLATBUFFERS_GENERATED_CSO_CSO_H_
