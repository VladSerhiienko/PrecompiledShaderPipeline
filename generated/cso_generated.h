// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CSO_CSO_H_
#define FLATBUFFERS_GENERATED_CSO_CSO_H_

#include "flatbuffers/flatbuffers.h"

namespace cso {

struct UniqueString;

struct UniqueBuffer;

struct CompiledShaderInfo;

struct ReflectedStructMember;

struct ReflectedType;

struct MemoryRange;

struct ReflectedResourceState;

struct ReflectedResource;

struct ReflectedConstant;

struct ReflectedShader;

struct CompiledShader;

struct CompiledShaderCollection;

enum Version {
  Version_Default = 0,
  Version_Value = 1,
  Version_MIN = Version_Default,
  Version_MAX = Version_Value
};

inline const Version (&EnumValuesVersion())[2] {
  static const Version values[] = {
    Version_Default,
    Version_Value
  };
  return values;
}

inline const char * const *EnumNamesVersion() {
  static const char * const names[] = {
    "Default",
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameVersion(Version e) {
  if (e < Version_Default || e > Version_Value) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVersion()[index];
}

enum IR {
  IR_Default = 0,
  IR_SPIRV = 1,
  IR_MIN = IR_Default,
  IR_MAX = IR_SPIRV
};

inline const IR (&EnumValuesIR())[2] {
  static const IR values[] = {
    IR_Default,
    IR_SPIRV
  };
  return values;
}

inline const char * const *EnumNamesIR() {
  static const char * const names[] = {
    "Default",
    "SPIRV",
    nullptr
  };
  return names;
}

inline const char *EnumNameIR(IR e) {
  if (e < IR_Default || e > IR_SPIRV) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIR()[index];
}

enum DecorationValue {
  DecorationValue_Default = 0,
  DecorationValue_Invalid = 4294967295,
  DecorationValue_MIN = DecorationValue_Default,
  DecorationValue_MAX = DecorationValue_Invalid
};

inline const DecorationValue (&EnumValuesDecorationValue())[2] {
  static const DecorationValue values[] = {
    DecorationValue_Default,
    DecorationValue_Invalid
  };
  return values;
}

inline const char *EnumNameDecorationValue(DecorationValue e) {
  switch (e) {
    case DecorationValue_Default: return "Default";
    case DecorationValue_Invalid: return "Invalid";
    default: return "";
  }
}

enum ArrayLength {
  ArrayLength_Undefined = 0,
  ArrayLength_Default = 1,
  ArrayLength_ValueBitMask = 2147483647,
  ArrayLength_IsStaticBitMask = 2147483648,
  ArrayLength_MIN = ArrayLength_Undefined,
  ArrayLength_MAX = ArrayLength_IsStaticBitMask
};

inline const ArrayLength (&EnumValuesArrayLength())[4] {
  static const ArrayLength values[] = {
    ArrayLength_Undefined,
    ArrayLength_Default,
    ArrayLength_ValueBitMask,
    ArrayLength_IsStaticBitMask
  };
  return values;
}

inline const char *EnumNameArrayLength(ArrayLength e) {
  switch (e) {
    case ArrayLength_Undefined: return "Undefined";
    case ArrayLength_Default: return "Default";
    case ArrayLength_ValueBitMask: return "ValueBitMask";
    case ArrayLength_IsStaticBitMask: return "IsStaticBitMask";
    default: return "";
  }
}

enum ReflectedConstantBit {
  ReflectedConstantBit_None = 0,
  ReflectedConstantBit_IsSpecializationBit = 1,
  ReflectedConstantBit_IsUsedAsArrayLengthBit = 2,
  ReflectedConstantBit_IsUsedAsLUT = 4,
  ReflectedConstantBit_MIN = ReflectedConstantBit_None,
  ReflectedConstantBit_MAX = ReflectedConstantBit_IsUsedAsLUT
};

inline const ReflectedConstantBit (&EnumValuesReflectedConstantBit())[4] {
  static const ReflectedConstantBit values[] = {
    ReflectedConstantBit_None,
    ReflectedConstantBit_IsSpecializationBit,
    ReflectedConstantBit_IsUsedAsArrayLengthBit,
    ReflectedConstantBit_IsUsedAsLUT
  };
  return values;
}

inline const char * const *EnumNamesReflectedConstantBit() {
  static const char * const names[] = {
    "None",
    "IsSpecializationBit",
    "IsUsedAsArrayLengthBit",
    "",
    "IsUsedAsLUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameReflectedConstantBit(ReflectedConstantBit e) {
  if (e < ReflectedConstantBit_None || e > ReflectedConstantBit_IsUsedAsLUT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReflectedConstantBit()[index];
}

enum Shader {
  Shader_Vertex = 0,
  Shader_Fragment = 1,
  Shader_Compute = 2,
  Shader_Geometry = 3,
  Shader_TessControl = 4,
  Shader_TessEvaluation = 5,
  Shader_RayGeneration = 6,
  Shader_AnyHit = 7,
  Shader_ClosestHit = 8,
  Shader_Miss = 9,
  Shader_Intersection = 10,
  Shader_Callable = 11,
  Shader_Task = 12,
  Shader_Mesh = 13,
  Shader_MIN = Shader_Vertex,
  Shader_MAX = Shader_Mesh
};

inline const Shader (&EnumValuesShader())[14] {
  static const Shader values[] = {
    Shader_Vertex,
    Shader_Fragment,
    Shader_Compute,
    Shader_Geometry,
    Shader_TessControl,
    Shader_TessEvaluation,
    Shader_RayGeneration,
    Shader_AnyHit,
    Shader_ClosestHit,
    Shader_Miss,
    Shader_Intersection,
    Shader_Callable,
    Shader_Task,
    Shader_Mesh
  };
  return values;
}

inline const char * const *EnumNamesShader() {
  static const char * const names[] = {
    "Vertex",
    "Fragment",
    "Compute",
    "Geometry",
    "TessControl",
    "TessEvaluation",
    "RayGeneration",
    "AnyHit",
    "ClosestHit",
    "Miss",
    "Intersection",
    "Callable",
    "Task",
    "Mesh",
    nullptr
  };
  return names;
}

inline const char *EnumNameShader(Shader e) {
  if (e < Shader_Vertex || e > Shader_Mesh) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShader()[index];
}

enum ReflectedPrimitiveType {
  ReflectedPrimitiveType_Struct = 0,
  ReflectedPrimitiveType_Bool = 1,
  ReflectedPrimitiveType_Char = 2,
  ReflectedPrimitiveType_Short = 3,
  ReflectedPrimitiveType_Int = 4,
  ReflectedPrimitiveType_Long = 5,
  ReflectedPrimitiveType_UChar = 6,
  ReflectedPrimitiveType_UShort = 7,
  ReflectedPrimitiveType_UInt = 8,
  ReflectedPrimitiveType_ULong = 9,
  ReflectedPrimitiveType_Half = 10,
  ReflectedPrimitiveType_Float = 11,
  ReflectedPrimitiveType_Double = 12,
  ReflectedPrimitiveType_Image = 13,
  ReflectedPrimitiveType_Sampler = 14,
  ReflectedPrimitiveType_SampledImage = 15,
  ReflectedPrimitiveType_AtomicCounter = 16,
  ReflectedPrimitiveType_AccelerationStructure = 17,
  ReflectedPrimitiveType_ControlPointerArray = 18,
  ReflectedPrimitiveType_MIN = ReflectedPrimitiveType_Struct,
  ReflectedPrimitiveType_MAX = ReflectedPrimitiveType_ControlPointerArray
};

inline const ReflectedPrimitiveType (&EnumValuesReflectedPrimitiveType())[19] {
  static const ReflectedPrimitiveType values[] = {
    ReflectedPrimitiveType_Struct,
    ReflectedPrimitiveType_Bool,
    ReflectedPrimitiveType_Char,
    ReflectedPrimitiveType_Short,
    ReflectedPrimitiveType_Int,
    ReflectedPrimitiveType_Long,
    ReflectedPrimitiveType_UChar,
    ReflectedPrimitiveType_UShort,
    ReflectedPrimitiveType_UInt,
    ReflectedPrimitiveType_ULong,
    ReflectedPrimitiveType_Half,
    ReflectedPrimitiveType_Float,
    ReflectedPrimitiveType_Double,
    ReflectedPrimitiveType_Image,
    ReflectedPrimitiveType_Sampler,
    ReflectedPrimitiveType_SampledImage,
    ReflectedPrimitiveType_AtomicCounter,
    ReflectedPrimitiveType_AccelerationStructure,
    ReflectedPrimitiveType_ControlPointerArray
  };
  return values;
}

inline const char * const *EnumNamesReflectedPrimitiveType() {
  static const char * const names[] = {
    "Struct",
    "Bool",
    "Char",
    "Short",
    "Int",
    "Long",
    "UChar",
    "UShort",
    "UInt",
    "ULong",
    "Half",
    "Float",
    "Double",
    "Image",
    "Sampler",
    "SampledImage",
    "AtomicCounter",
    "AccelerationStructure",
    "ControlPointerArray",
    nullptr
  };
  return names;
}

inline const char *EnumNameReflectedPrimitiveType(ReflectedPrimitiveType e) {
  if (e < ReflectedPrimitiveType_Struct || e > ReflectedPrimitiveType_ControlPointerArray) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReflectedPrimitiveType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ReflectedStructMember FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t name_index_;
  uint32_t type_index_;
  uint32_t byte_offset_;
  uint32_t effective_byte_size_;
  uint32_t occupied_byte_size_;

 public:
  ReflectedStructMember() {
    memset(static_cast<void *>(this), 0, sizeof(ReflectedStructMember));
  }
  ReflectedStructMember(uint32_t _name_index, uint32_t _type_index, uint32_t _byte_offset, uint32_t _effective_byte_size, uint32_t _occupied_byte_size)
      : name_index_(flatbuffers::EndianScalar(_name_index)),
        type_index_(flatbuffers::EndianScalar(_type_index)),
        byte_offset_(flatbuffers::EndianScalar(_byte_offset)),
        effective_byte_size_(flatbuffers::EndianScalar(_effective_byte_size)),
        occupied_byte_size_(flatbuffers::EndianScalar(_occupied_byte_size)) {
  }
  uint32_t name_index() const {
    return flatbuffers::EndianScalar(name_index_);
  }
  void mutate_name_index(uint32_t _name_index) {
    flatbuffers::WriteScalar(&name_index_, _name_index);
  }
  uint32_t type_index() const {
    return flatbuffers::EndianScalar(type_index_);
  }
  void mutate_type_index(uint32_t _type_index) {
    flatbuffers::WriteScalar(&type_index_, _type_index);
  }
  uint32_t byte_offset() const {
    return flatbuffers::EndianScalar(byte_offset_);
  }
  void mutate_byte_offset(uint32_t _byte_offset) {
    flatbuffers::WriteScalar(&byte_offset_, _byte_offset);
  }
  uint32_t effective_byte_size() const {
    return flatbuffers::EndianScalar(effective_byte_size_);
  }
  void mutate_effective_byte_size(uint32_t _effective_byte_size) {
    flatbuffers::WriteScalar(&effective_byte_size_, _effective_byte_size);
  }
  uint32_t occupied_byte_size() const {
    return flatbuffers::EndianScalar(occupied_byte_size_);
  }
  void mutate_occupied_byte_size(uint32_t _occupied_byte_size) {
    flatbuffers::WriteScalar(&occupied_byte_size_, _occupied_byte_size);
  }
};
FLATBUFFERS_STRUCT_END(ReflectedStructMember, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MemoryRange FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t byte_offset_;
  uint32_t byte_size_;

 public:
  MemoryRange() {
    memset(static_cast<void *>(this), 0, sizeof(MemoryRange));
  }
  MemoryRange(uint32_t _byte_offset, uint32_t _byte_size)
      : byte_offset_(flatbuffers::EndianScalar(_byte_offset)),
        byte_size_(flatbuffers::EndianScalar(_byte_size)) {
  }
  uint32_t byte_offset() const {
    return flatbuffers::EndianScalar(byte_offset_);
  }
  void mutate_byte_offset(uint32_t _byte_offset) {
    flatbuffers::WriteScalar(&byte_offset_, _byte_offset);
  }
  uint32_t byte_size() const {
    return flatbuffers::EndianScalar(byte_size_);
  }
  void mutate_byte_size(uint32_t _byte_size) {
    flatbuffers::WriteScalar(&byte_size_, _byte_size);
  }
};
FLATBUFFERS_STRUCT_END(MemoryRange, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ReflectedResource FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t name_index_;
  uint32_t type_index_;
  uint32_t descriptor_set_;
  uint32_t binding_;
  uint32_t location_;

 public:
  ReflectedResource() {
    memset(static_cast<void *>(this), 0, sizeof(ReflectedResource));
  }
  ReflectedResource(uint32_t _name_index, uint32_t _type_index, uint32_t _descriptor_set, uint32_t _binding, uint32_t _location)
      : name_index_(flatbuffers::EndianScalar(_name_index)),
        type_index_(flatbuffers::EndianScalar(_type_index)),
        descriptor_set_(flatbuffers::EndianScalar(_descriptor_set)),
        binding_(flatbuffers::EndianScalar(_binding)),
        location_(flatbuffers::EndianScalar(_location)) {
  }
  uint32_t name_index() const {
    return flatbuffers::EndianScalar(name_index_);
  }
  void mutate_name_index(uint32_t _name_index) {
    flatbuffers::WriteScalar(&name_index_, _name_index);
  }
  uint32_t type_index() const {
    return flatbuffers::EndianScalar(type_index_);
  }
  void mutate_type_index(uint32_t _type_index) {
    flatbuffers::WriteScalar(&type_index_, _type_index);
  }
  uint32_t descriptor_set() const {
    return flatbuffers::EndianScalar(descriptor_set_);
  }
  void mutate_descriptor_set(uint32_t _descriptor_set) {
    flatbuffers::WriteScalar(&descriptor_set_, _descriptor_set);
  }
  uint32_t binding() const {
    return flatbuffers::EndianScalar(binding_);
  }
  void mutate_binding(uint32_t _binding) {
    flatbuffers::WriteScalar(&binding_, _binding);
  }
  uint32_t location() const {
    return flatbuffers::EndianScalar(location_);
  }
  void mutate_location(uint32_t _location) {
    flatbuffers::WriteScalar(&location_, _location);
  }
};
FLATBUFFERS_STRUCT_END(ReflectedResource, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ReflectedConstant FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t name_index_;
  uint32_t macro_name_index_;
  uint64_t default_scalar_u64_;
  uint32_t constant_id_;
  uint32_t type_index_;
  uint32_t bits_;
  int32_t padding0__;

 public:
  ReflectedConstant() {
    memset(static_cast<void *>(this), 0, sizeof(ReflectedConstant));
  }
  ReflectedConstant(uint32_t _name_index, uint32_t _macro_name_index, uint64_t _default_scalar_u64, uint32_t _constant_id, uint32_t _type_index, uint32_t _bits)
      : name_index_(flatbuffers::EndianScalar(_name_index)),
        macro_name_index_(flatbuffers::EndianScalar(_macro_name_index)),
        default_scalar_u64_(flatbuffers::EndianScalar(_default_scalar_u64)),
        constant_id_(flatbuffers::EndianScalar(_constant_id)),
        type_index_(flatbuffers::EndianScalar(_type_index)),
        bits_(flatbuffers::EndianScalar(_bits)),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t name_index() const {
    return flatbuffers::EndianScalar(name_index_);
  }
  void mutate_name_index(uint32_t _name_index) {
    flatbuffers::WriteScalar(&name_index_, _name_index);
  }
  uint32_t macro_name_index() const {
    return flatbuffers::EndianScalar(macro_name_index_);
  }
  void mutate_macro_name_index(uint32_t _macro_name_index) {
    flatbuffers::WriteScalar(&macro_name_index_, _macro_name_index);
  }
  uint64_t default_scalar_u64() const {
    return flatbuffers::EndianScalar(default_scalar_u64_);
  }
  void mutate_default_scalar_u64(uint64_t _default_scalar_u64) {
    flatbuffers::WriteScalar(&default_scalar_u64_, _default_scalar_u64);
  }
  uint32_t constant_id() const {
    return flatbuffers::EndianScalar(constant_id_);
  }
  void mutate_constant_id(uint32_t _constant_id) {
    flatbuffers::WriteScalar(&constant_id_, _constant_id);
  }
  uint32_t type_index() const {
    return flatbuffers::EndianScalar(type_index_);
  }
  void mutate_type_index(uint32_t _type_index) {
    flatbuffers::WriteScalar(&type_index_, _type_index);
  }
  uint32_t bits() const {
    return flatbuffers::EndianScalar(bits_);
  }
  void mutate_bits(uint32_t _bits) {
    flatbuffers::WriteScalar(&bits_, _bits);
  }
};
FLATBUFFERS_STRUCT_END(ReflectedConstant, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CompiledShader FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t preprocessed_string_index_;
  uint32_t assembly_string_index_;
  uint32_t compiled_glsl_string_index_;
  uint32_t compiled_msl_string_index_;
  uint32_t compiled_buffer_index_;
  uint32_t reflected_shader_index_;
  uint32_t type_;

 public:
  CompiledShader() {
    memset(static_cast<void *>(this), 0, sizeof(CompiledShader));
  }
  CompiledShader(uint32_t _preprocessed_string_index, uint32_t _assembly_string_index, uint32_t _compiled_glsl_string_index, uint32_t _compiled_msl_string_index, uint32_t _compiled_buffer_index, uint32_t _reflected_shader_index, IR _type)
      : preprocessed_string_index_(flatbuffers::EndianScalar(_preprocessed_string_index)),
        assembly_string_index_(flatbuffers::EndianScalar(_assembly_string_index)),
        compiled_glsl_string_index_(flatbuffers::EndianScalar(_compiled_glsl_string_index)),
        compiled_msl_string_index_(flatbuffers::EndianScalar(_compiled_msl_string_index)),
        compiled_buffer_index_(flatbuffers::EndianScalar(_compiled_buffer_index)),
        reflected_shader_index_(flatbuffers::EndianScalar(_reflected_shader_index)),
        type_(flatbuffers::EndianScalar(static_cast<uint32_t>(_type))) {
  }
  uint32_t preprocessed_string_index() const {
    return flatbuffers::EndianScalar(preprocessed_string_index_);
  }
  void mutate_preprocessed_string_index(uint32_t _preprocessed_string_index) {
    flatbuffers::WriteScalar(&preprocessed_string_index_, _preprocessed_string_index);
  }
  uint32_t assembly_string_index() const {
    return flatbuffers::EndianScalar(assembly_string_index_);
  }
  void mutate_assembly_string_index(uint32_t _assembly_string_index) {
    flatbuffers::WriteScalar(&assembly_string_index_, _assembly_string_index);
  }
  uint32_t compiled_glsl_string_index() const {
    return flatbuffers::EndianScalar(compiled_glsl_string_index_);
  }
  void mutate_compiled_glsl_string_index(uint32_t _compiled_glsl_string_index) {
    flatbuffers::WriteScalar(&compiled_glsl_string_index_, _compiled_glsl_string_index);
  }
  uint32_t compiled_msl_string_index() const {
    return flatbuffers::EndianScalar(compiled_msl_string_index_);
  }
  void mutate_compiled_msl_string_index(uint32_t _compiled_msl_string_index) {
    flatbuffers::WriteScalar(&compiled_msl_string_index_, _compiled_msl_string_index);
  }
  uint32_t compiled_buffer_index() const {
    return flatbuffers::EndianScalar(compiled_buffer_index_);
  }
  void mutate_compiled_buffer_index(uint32_t _compiled_buffer_index) {
    flatbuffers::WriteScalar(&compiled_buffer_index_, _compiled_buffer_index);
  }
  uint32_t reflected_shader_index() const {
    return flatbuffers::EndianScalar(reflected_shader_index_);
  }
  void mutate_reflected_shader_index(uint32_t _reflected_shader_index) {
    flatbuffers::WriteScalar(&reflected_shader_index_, _reflected_shader_index);
  }
  IR type() const {
    return static_cast<IR>(flatbuffers::EndianScalar(type_));
  }
  void mutate_type(IR _type) {
    flatbuffers::WriteScalar(&type_, static_cast<uint32_t>(_type));
  }
};
FLATBUFFERS_STRUCT_END(CompiledShader, 28);

struct UniqueString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENTS = 4
  };
  const flatbuffers::String *contents() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENTS);
  }
  flatbuffers::String *mutable_contents() {
    return GetPointer<flatbuffers::String *>(VT_CONTENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyString(contents()) &&
           verifier.EndTable();
  }
};

struct UniqueStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contents(flatbuffers::Offset<flatbuffers::String> contents) {
    fbb_.AddOffset(UniqueString::VT_CONTENTS, contents);
  }
  explicit UniqueStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueStringBuilder &operator=(const UniqueStringBuilder &);
  flatbuffers::Offset<UniqueString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueString>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueString> CreateUniqueString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> contents = 0) {
  UniqueStringBuilder builder_(_fbb);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline flatbuffers::Offset<UniqueString> CreateUniqueStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *contents = nullptr) {
  auto contents__ = contents ? _fbb.CreateString(contents) : 0;
  return cso::CreateUniqueString(
      _fbb,
      contents__);
}

struct UniqueBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENTS = 4
  };
  const flatbuffers::Vector<int8_t> *contents() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_CONTENTS);
  }
  flatbuffers::Vector<int8_t> *mutable_contents() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_CONTENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) &&
           verifier.EndTable();
  }
};

struct UniqueBufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contents(flatbuffers::Offset<flatbuffers::Vector<int8_t>> contents) {
    fbb_.AddOffset(UniqueBuffer::VT_CONTENTS, contents);
  }
  explicit UniqueBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueBufferBuilder &operator=(const UniqueBufferBuilder &);
  flatbuffers::Offset<UniqueBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueBuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueBuffer> CreateUniqueBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> contents = 0) {
  UniqueBufferBuilder builder_(_fbb);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline flatbuffers::Offset<UniqueBuffer> CreateUniqueBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *contents = nullptr) {
  auto contents__ = contents ? _fbb.CreateVector<int8_t>(*contents) : 0;
  return cso::CreateUniqueBuffer(
      _fbb,
      contents__);
}

struct CompiledShaderInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COMPILED_SHADER_INDEX = 6,
    VT_ASSET_STRING_INDEX = 8,
    VT_DEFINITIONS_STRING_INDEX = 10,
    VT_DEFINITIONS_STRING_INDICES = 12,
    VT_INCLUDED_FILES_STRING_INDICES = 14
  };
  Shader type() const {
    return static_cast<Shader>(GetField<uint32_t>(VT_TYPE, 0));
  }
  bool mutate_type(Shader _type) {
    return SetField<uint32_t>(VT_TYPE, static_cast<uint32_t>(_type), 0);
  }
  uint32_t compiled_shader_index() const {
    return GetField<uint32_t>(VT_COMPILED_SHADER_INDEX, 0);
  }
  bool mutate_compiled_shader_index(uint32_t _compiled_shader_index) {
    return SetField<uint32_t>(VT_COMPILED_SHADER_INDEX, _compiled_shader_index, 0);
  }
  uint32_t asset_string_index() const {
    return GetField<uint32_t>(VT_ASSET_STRING_INDEX, 0);
  }
  bool mutate_asset_string_index(uint32_t _asset_string_index) {
    return SetField<uint32_t>(VT_ASSET_STRING_INDEX, _asset_string_index, 0);
  }
  uint32_t definitions_string_index() const {
    return GetField<uint32_t>(VT_DEFINITIONS_STRING_INDEX, 0);
  }
  bool mutate_definitions_string_index(uint32_t _definitions_string_index) {
    return SetField<uint32_t>(VT_DEFINITIONS_STRING_INDEX, _definitions_string_index, 0);
  }
  const flatbuffers::Vector<uint32_t> *definitions_string_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DEFINITIONS_STRING_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_definitions_string_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_DEFINITIONS_STRING_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *included_files_string_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INCLUDED_FILES_STRING_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_included_files_string_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INCLUDED_FILES_STRING_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_COMPILED_SHADER_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_ASSET_STRING_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_DEFINITIONS_STRING_INDEX) &&
           VerifyOffset(verifier, VT_DEFINITIONS_STRING_INDICES) &&
           verifier.VerifyVector(definitions_string_indices()) &&
           VerifyOffset(verifier, VT_INCLUDED_FILES_STRING_INDICES) &&
           verifier.VerifyVector(included_files_string_indices()) &&
           verifier.EndTable();
  }
};

struct CompiledShaderInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(Shader type) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_TYPE, static_cast<uint32_t>(type), 0);
  }
  void add_compiled_shader_index(uint32_t compiled_shader_index) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_COMPILED_SHADER_INDEX, compiled_shader_index, 0);
  }
  void add_asset_string_index(uint32_t asset_string_index) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_ASSET_STRING_INDEX, asset_string_index, 0);
  }
  void add_definitions_string_index(uint32_t definitions_string_index) {
    fbb_.AddElement<uint32_t>(CompiledShaderInfo::VT_DEFINITIONS_STRING_INDEX, definitions_string_index, 0);
  }
  void add_definitions_string_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> definitions_string_indices) {
    fbb_.AddOffset(CompiledShaderInfo::VT_DEFINITIONS_STRING_INDICES, definitions_string_indices);
  }
  void add_included_files_string_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> included_files_string_indices) {
    fbb_.AddOffset(CompiledShaderInfo::VT_INCLUDED_FILES_STRING_INDICES, included_files_string_indices);
  }
  explicit CompiledShaderInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompiledShaderInfoBuilder &operator=(const CompiledShaderInfoBuilder &);
  flatbuffers::Offset<CompiledShaderInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledShaderInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledShaderInfo> CreateCompiledShaderInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    Shader type = Shader_Vertex,
    uint32_t compiled_shader_index = 0,
    uint32_t asset_string_index = 0,
    uint32_t definitions_string_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> definitions_string_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> included_files_string_indices = 0) {
  CompiledShaderInfoBuilder builder_(_fbb);
  builder_.add_included_files_string_indices(included_files_string_indices);
  builder_.add_definitions_string_indices(definitions_string_indices);
  builder_.add_definitions_string_index(definitions_string_index);
  builder_.add_asset_string_index(asset_string_index);
  builder_.add_compiled_shader_index(compiled_shader_index);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledShaderInfo> CreateCompiledShaderInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Shader type = Shader_Vertex,
    uint32_t compiled_shader_index = 0,
    uint32_t asset_string_index = 0,
    uint32_t definitions_string_index = 0,
    const std::vector<uint32_t> *definitions_string_indices = nullptr,
    const std::vector<uint32_t> *included_files_string_indices = nullptr) {
  auto definitions_string_indices__ = definitions_string_indices ? _fbb.CreateVector<uint32_t>(*definitions_string_indices) : 0;
  auto included_files_string_indices__ = included_files_string_indices ? _fbb.CreateVector<uint32_t>(*included_files_string_indices) : 0;
  return cso::CreateCompiledShaderInfo(
      _fbb,
      type,
      compiled_shader_index,
      asset_string_index,
      definitions_string_index,
      definitions_string_indices__,
      included_files_string_indices__);
}

struct ReflectedType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_INDEX = 4,
    VT_ELEMENT_PRIMITIVE_TYPE = 6,
    VT_ELEMENT_BYTE_SIZE = 8,
    VT_ELEMENT_VECTOR_LENGTH = 10,
    VT_ELEMENT_COLUMN_COUNT = 12,
    VT_ELEMENT_MATRIX_STRIDE = 14,
    VT_ARRAY_LENGTH_WITH_BITS = 16,
    VT_ARRAY_BYTE_STRIDE = 18,
    VT_EFFECTIVE_BYTE_SIZE = 20,
    VT_MEMBER_TYPES = 22
  };
  uint32_t name_index() const {
    return GetField<uint32_t>(VT_NAME_INDEX, 0);
  }
  bool mutate_name_index(uint32_t _name_index) {
    return SetField<uint32_t>(VT_NAME_INDEX, _name_index, 0);
  }
  ReflectedPrimitiveType element_primitive_type() const {
    return static_cast<ReflectedPrimitiveType>(GetField<uint32_t>(VT_ELEMENT_PRIMITIVE_TYPE, 0));
  }
  bool mutate_element_primitive_type(ReflectedPrimitiveType _element_primitive_type) {
    return SetField<uint32_t>(VT_ELEMENT_PRIMITIVE_TYPE, static_cast<uint32_t>(_element_primitive_type), 0);
  }
  uint32_t element_byte_size() const {
    return GetField<uint32_t>(VT_ELEMENT_BYTE_SIZE, 0);
  }
  bool mutate_element_byte_size(uint32_t _element_byte_size) {
    return SetField<uint32_t>(VT_ELEMENT_BYTE_SIZE, _element_byte_size, 0);
  }
  uint32_t element_vector_length() const {
    return GetField<uint32_t>(VT_ELEMENT_VECTOR_LENGTH, 0);
  }
  bool mutate_element_vector_length(uint32_t _element_vector_length) {
    return SetField<uint32_t>(VT_ELEMENT_VECTOR_LENGTH, _element_vector_length, 0);
  }
  uint32_t element_column_count() const {
    return GetField<uint32_t>(VT_ELEMENT_COLUMN_COUNT, 0);
  }
  bool mutate_element_column_count(uint32_t _element_column_count) {
    return SetField<uint32_t>(VT_ELEMENT_COLUMN_COUNT, _element_column_count, 0);
  }
  uint32_t element_matrix_stride() const {
    return GetField<uint32_t>(VT_ELEMENT_MATRIX_STRIDE, 0);
  }
  bool mutate_element_matrix_stride(uint32_t _element_matrix_stride) {
    return SetField<uint32_t>(VT_ELEMENT_MATRIX_STRIDE, _element_matrix_stride, 0);
  }
  uint32_t array_length_with_bits() const {
    return GetField<uint32_t>(VT_ARRAY_LENGTH_WITH_BITS, 0);
  }
  bool mutate_array_length_with_bits(uint32_t _array_length_with_bits) {
    return SetField<uint32_t>(VT_ARRAY_LENGTH_WITH_BITS, _array_length_with_bits, 0);
  }
  uint32_t array_byte_stride() const {
    return GetField<uint32_t>(VT_ARRAY_BYTE_STRIDE, 0);
  }
  bool mutate_array_byte_stride(uint32_t _array_byte_stride) {
    return SetField<uint32_t>(VT_ARRAY_BYTE_STRIDE, _array_byte_stride, 0);
  }
  uint32_t effective_byte_size() const {
    return GetField<uint32_t>(VT_EFFECTIVE_BYTE_SIZE, 0);
  }
  bool mutate_effective_byte_size(uint32_t _effective_byte_size) {
    return SetField<uint32_t>(VT_EFFECTIVE_BYTE_SIZE, _effective_byte_size, 0);
  }
  const flatbuffers::Vector<const ReflectedStructMember *> *member_types() const {
    return GetPointer<const flatbuffers::Vector<const ReflectedStructMember *> *>(VT_MEMBER_TYPES);
  }
  flatbuffers::Vector<const ReflectedStructMember *> *mutable_member_types() {
    return GetPointer<flatbuffers::Vector<const ReflectedStructMember *> *>(VT_MEMBER_TYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NAME_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_PRIMITIVE_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_BYTE_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_VECTOR_LENGTH) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_COLUMN_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_MATRIX_STRIDE) &&
           VerifyField<uint32_t>(verifier, VT_ARRAY_LENGTH_WITH_BITS) &&
           VerifyField<uint32_t>(verifier, VT_ARRAY_BYTE_STRIDE) &&
           VerifyField<uint32_t>(verifier, VT_EFFECTIVE_BYTE_SIZE) &&
           VerifyOffset(verifier, VT_MEMBER_TYPES) &&
           verifier.VerifyVector(member_types()) &&
           verifier.EndTable();
  }
};

struct ReflectedTypeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_index(uint32_t name_index) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_NAME_INDEX, name_index, 0);
  }
  void add_element_primitive_type(ReflectedPrimitiveType element_primitive_type) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ELEMENT_PRIMITIVE_TYPE, static_cast<uint32_t>(element_primitive_type), 0);
  }
  void add_element_byte_size(uint32_t element_byte_size) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ELEMENT_BYTE_SIZE, element_byte_size, 0);
  }
  void add_element_vector_length(uint32_t element_vector_length) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ELEMENT_VECTOR_LENGTH, element_vector_length, 0);
  }
  void add_element_column_count(uint32_t element_column_count) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ELEMENT_COLUMN_COUNT, element_column_count, 0);
  }
  void add_element_matrix_stride(uint32_t element_matrix_stride) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ELEMENT_MATRIX_STRIDE, element_matrix_stride, 0);
  }
  void add_array_length_with_bits(uint32_t array_length_with_bits) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ARRAY_LENGTH_WITH_BITS, array_length_with_bits, 0);
  }
  void add_array_byte_stride(uint32_t array_byte_stride) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_ARRAY_BYTE_STRIDE, array_byte_stride, 0);
  }
  void add_effective_byte_size(uint32_t effective_byte_size) {
    fbb_.AddElement<uint32_t>(ReflectedType::VT_EFFECTIVE_BYTE_SIZE, effective_byte_size, 0);
  }
  void add_member_types(flatbuffers::Offset<flatbuffers::Vector<const ReflectedStructMember *>> member_types) {
    fbb_.AddOffset(ReflectedType::VT_MEMBER_TYPES, member_types);
  }
  explicit ReflectedTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReflectedTypeBuilder &operator=(const ReflectedTypeBuilder &);
  flatbuffers::Offset<ReflectedType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReflectedType>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReflectedType> CreateReflectedType(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t name_index = 0,
    ReflectedPrimitiveType element_primitive_type = ReflectedPrimitiveType_Struct,
    uint32_t element_byte_size = 0,
    uint32_t element_vector_length = 0,
    uint32_t element_column_count = 0,
    uint32_t element_matrix_stride = 0,
    uint32_t array_length_with_bits = 0,
    uint32_t array_byte_stride = 0,
    uint32_t effective_byte_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ReflectedStructMember *>> member_types = 0) {
  ReflectedTypeBuilder builder_(_fbb);
  builder_.add_member_types(member_types);
  builder_.add_effective_byte_size(effective_byte_size);
  builder_.add_array_byte_stride(array_byte_stride);
  builder_.add_array_length_with_bits(array_length_with_bits);
  builder_.add_element_matrix_stride(element_matrix_stride);
  builder_.add_element_column_count(element_column_count);
  builder_.add_element_vector_length(element_vector_length);
  builder_.add_element_byte_size(element_byte_size);
  builder_.add_element_primitive_type(element_primitive_type);
  builder_.add_name_index(name_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReflectedType> CreateReflectedTypeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t name_index = 0,
    ReflectedPrimitiveType element_primitive_type = ReflectedPrimitiveType_Struct,
    uint32_t element_byte_size = 0,
    uint32_t element_vector_length = 0,
    uint32_t element_column_count = 0,
    uint32_t element_matrix_stride = 0,
    uint32_t array_length_with_bits = 0,
    uint32_t array_byte_stride = 0,
    uint32_t effective_byte_size = 0,
    const std::vector<ReflectedStructMember> *member_types = nullptr) {
  auto member_types__ = member_types ? _fbb.CreateVectorOfStructs<ReflectedStructMember>(*member_types) : 0;
  return cso::CreateReflectedType(
      _fbb,
      name_index,
      element_primitive_type,
      element_byte_size,
      element_vector_length,
      element_column_count,
      element_matrix_stride,
      array_length_with_bits,
      array_byte_stride,
      effective_byte_size,
      member_types__);
}

struct ReflectedResourceState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_ACTIVE = 4,
    VT_ACTIVE_RANGES = 6
  };
  bool is_active() const {
    return GetField<uint8_t>(VT_IS_ACTIVE, 0) != 0;
  }
  bool mutate_is_active(bool _is_active) {
    return SetField<uint8_t>(VT_IS_ACTIVE, static_cast<uint8_t>(_is_active), 0);
  }
  const flatbuffers::Vector<const MemoryRange *> *active_ranges() const {
    return GetPointer<const flatbuffers::Vector<const MemoryRange *> *>(VT_ACTIVE_RANGES);
  }
  flatbuffers::Vector<const MemoryRange *> *mutable_active_ranges() {
    return GetPointer<flatbuffers::Vector<const MemoryRange *> *>(VT_ACTIVE_RANGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_ACTIVE) &&
           VerifyOffset(verifier, VT_ACTIVE_RANGES) &&
           verifier.VerifyVector(active_ranges()) &&
           verifier.EndTable();
  }
};

struct ReflectedResourceStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_active(bool is_active) {
    fbb_.AddElement<uint8_t>(ReflectedResourceState::VT_IS_ACTIVE, static_cast<uint8_t>(is_active), 0);
  }
  void add_active_ranges(flatbuffers::Offset<flatbuffers::Vector<const MemoryRange *>> active_ranges) {
    fbb_.AddOffset(ReflectedResourceState::VT_ACTIVE_RANGES, active_ranges);
  }
  explicit ReflectedResourceStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReflectedResourceStateBuilder &operator=(const ReflectedResourceStateBuilder &);
  flatbuffers::Offset<ReflectedResourceState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReflectedResourceState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReflectedResourceState> CreateReflectedResourceState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_active = false,
    flatbuffers::Offset<flatbuffers::Vector<const MemoryRange *>> active_ranges = 0) {
  ReflectedResourceStateBuilder builder_(_fbb);
  builder_.add_active_ranges(active_ranges);
  builder_.add_is_active(is_active);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReflectedResourceState> CreateReflectedResourceStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_active = false,
    const std::vector<MemoryRange> *active_ranges = nullptr) {
  auto active_ranges__ = active_ranges ? _fbb.CreateVectorOfStructs<MemoryRange>(*active_ranges) : 0;
  return cso::CreateReflectedResourceState(
      _fbb,
      is_active,
      active_ranges__);
}

struct ReflectedShader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_INDEX = 4,
    VT_CONSTANT_INDICES = 6,
    VT_STAGE_INPUT_INDICES = 8,
    VT_STAGE_OUTPUT_INDICES = 10,
    VT_UNIFORM_BUFFER_INDICES = 12,
    VT_PUSH_CONSTANT_BUFFER_INDICES = 14,
    VT_SAMPLED_IMAGE_INDICES = 16,
    VT_SUBPASS_INPUT_INDICES = 18,
    VT_IMAGE_INDICES = 20,
    VT_SAMPLER_INDICES = 22,
    VT_STORAGE_IMAGE_INDICES = 24,
    VT_STORAGE_BUFFER_INDICES = 26,
    VT_UNIFORM_BUFFER_STATE_INDICES = 28,
    VT_PUSH_CONSTANT_BUFFER_STATE_INDICES = 30,
    VT_STORAGE_BUFFER_STATE_INDICES = 32
  };
  uint32_t name_index() const {
    return GetField<uint32_t>(VT_NAME_INDEX, 0);
  }
  bool mutate_name_index(uint32_t _name_index) {
    return SetField<uint32_t>(VT_NAME_INDEX, _name_index, 0);
  }
  const flatbuffers::Vector<uint32_t> *constant_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_CONSTANT_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_constant_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_CONSTANT_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *stage_input_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STAGE_INPUT_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_stage_input_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_STAGE_INPUT_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *stage_output_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STAGE_OUTPUT_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_stage_output_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_STAGE_OUTPUT_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *uniform_buffer_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_UNIFORM_BUFFER_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_uniform_buffer_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_UNIFORM_BUFFER_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *push_constant_buffer_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_PUSH_CONSTANT_BUFFER_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_push_constant_buffer_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_PUSH_CONSTANT_BUFFER_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *sampled_image_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SAMPLED_IMAGE_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_sampled_image_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_SAMPLED_IMAGE_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *subpass_input_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SUBPASS_INPUT_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_subpass_input_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_SUBPASS_INPUT_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *image_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_IMAGE_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_image_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_IMAGE_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *sampler_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SAMPLER_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_sampler_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_SAMPLER_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *storage_image_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STORAGE_IMAGE_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_storage_image_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_STORAGE_IMAGE_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *storage_buffer_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STORAGE_BUFFER_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_storage_buffer_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_STORAGE_BUFFER_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *uniform_buffer_state_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_UNIFORM_BUFFER_STATE_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_uniform_buffer_state_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_UNIFORM_BUFFER_STATE_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *push_constant_buffer_state_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_PUSH_CONSTANT_BUFFER_STATE_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_push_constant_buffer_state_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_PUSH_CONSTANT_BUFFER_STATE_INDICES);
  }
  const flatbuffers::Vector<uint32_t> *storage_buffer_state_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STORAGE_BUFFER_STATE_INDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_storage_buffer_state_indices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_STORAGE_BUFFER_STATE_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NAME_INDEX) &&
           VerifyOffset(verifier, VT_CONSTANT_INDICES) &&
           verifier.VerifyVector(constant_indices()) &&
           VerifyOffset(verifier, VT_STAGE_INPUT_INDICES) &&
           verifier.VerifyVector(stage_input_indices()) &&
           VerifyOffset(verifier, VT_STAGE_OUTPUT_INDICES) &&
           verifier.VerifyVector(stage_output_indices()) &&
           VerifyOffset(verifier, VT_UNIFORM_BUFFER_INDICES) &&
           verifier.VerifyVector(uniform_buffer_indices()) &&
           VerifyOffset(verifier, VT_PUSH_CONSTANT_BUFFER_INDICES) &&
           verifier.VerifyVector(push_constant_buffer_indices()) &&
           VerifyOffset(verifier, VT_SAMPLED_IMAGE_INDICES) &&
           verifier.VerifyVector(sampled_image_indices()) &&
           VerifyOffset(verifier, VT_SUBPASS_INPUT_INDICES) &&
           verifier.VerifyVector(subpass_input_indices()) &&
           VerifyOffset(verifier, VT_IMAGE_INDICES) &&
           verifier.VerifyVector(image_indices()) &&
           VerifyOffset(verifier, VT_SAMPLER_INDICES) &&
           verifier.VerifyVector(sampler_indices()) &&
           VerifyOffset(verifier, VT_STORAGE_IMAGE_INDICES) &&
           verifier.VerifyVector(storage_image_indices()) &&
           VerifyOffset(verifier, VT_STORAGE_BUFFER_INDICES) &&
           verifier.VerifyVector(storage_buffer_indices()) &&
           VerifyOffset(verifier, VT_UNIFORM_BUFFER_STATE_INDICES) &&
           verifier.VerifyVector(uniform_buffer_state_indices()) &&
           VerifyOffset(verifier, VT_PUSH_CONSTANT_BUFFER_STATE_INDICES) &&
           verifier.VerifyVector(push_constant_buffer_state_indices()) &&
           VerifyOffset(verifier, VT_STORAGE_BUFFER_STATE_INDICES) &&
           verifier.VerifyVector(storage_buffer_state_indices()) &&
           verifier.EndTable();
  }
};

struct ReflectedShaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_index(uint32_t name_index) {
    fbb_.AddElement<uint32_t>(ReflectedShader::VT_NAME_INDEX, name_index, 0);
  }
  void add_constant_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> constant_indices) {
    fbb_.AddOffset(ReflectedShader::VT_CONSTANT_INDICES, constant_indices);
  }
  void add_stage_input_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> stage_input_indices) {
    fbb_.AddOffset(ReflectedShader::VT_STAGE_INPUT_INDICES, stage_input_indices);
  }
  void add_stage_output_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> stage_output_indices) {
    fbb_.AddOffset(ReflectedShader::VT_STAGE_OUTPUT_INDICES, stage_output_indices);
  }
  void add_uniform_buffer_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniform_buffer_indices) {
    fbb_.AddOffset(ReflectedShader::VT_UNIFORM_BUFFER_INDICES, uniform_buffer_indices);
  }
  void add_push_constant_buffer_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> push_constant_buffer_indices) {
    fbb_.AddOffset(ReflectedShader::VT_PUSH_CONSTANT_BUFFER_INDICES, push_constant_buffer_indices);
  }
  void add_sampled_image_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sampled_image_indices) {
    fbb_.AddOffset(ReflectedShader::VT_SAMPLED_IMAGE_INDICES, sampled_image_indices);
  }
  void add_subpass_input_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> subpass_input_indices) {
    fbb_.AddOffset(ReflectedShader::VT_SUBPASS_INPUT_INDICES, subpass_input_indices);
  }
  void add_image_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> image_indices) {
    fbb_.AddOffset(ReflectedShader::VT_IMAGE_INDICES, image_indices);
  }
  void add_sampler_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sampler_indices) {
    fbb_.AddOffset(ReflectedShader::VT_SAMPLER_INDICES, sampler_indices);
  }
  void add_storage_image_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> storage_image_indices) {
    fbb_.AddOffset(ReflectedShader::VT_STORAGE_IMAGE_INDICES, storage_image_indices);
  }
  void add_storage_buffer_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> storage_buffer_indices) {
    fbb_.AddOffset(ReflectedShader::VT_STORAGE_BUFFER_INDICES, storage_buffer_indices);
  }
  void add_uniform_buffer_state_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniform_buffer_state_indices) {
    fbb_.AddOffset(ReflectedShader::VT_UNIFORM_BUFFER_STATE_INDICES, uniform_buffer_state_indices);
  }
  void add_push_constant_buffer_state_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> push_constant_buffer_state_indices) {
    fbb_.AddOffset(ReflectedShader::VT_PUSH_CONSTANT_BUFFER_STATE_INDICES, push_constant_buffer_state_indices);
  }
  void add_storage_buffer_state_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> storage_buffer_state_indices) {
    fbb_.AddOffset(ReflectedShader::VT_STORAGE_BUFFER_STATE_INDICES, storage_buffer_state_indices);
  }
  explicit ReflectedShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReflectedShaderBuilder &operator=(const ReflectedShaderBuilder &);
  flatbuffers::Offset<ReflectedShader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReflectedShader>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReflectedShader> CreateReflectedShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t name_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> constant_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> stage_input_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> stage_output_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniform_buffer_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> push_constant_buffer_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sampled_image_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> subpass_input_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> image_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sampler_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> storage_image_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> storage_buffer_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniform_buffer_state_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> push_constant_buffer_state_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> storage_buffer_state_indices = 0) {
  ReflectedShaderBuilder builder_(_fbb);
  builder_.add_storage_buffer_state_indices(storage_buffer_state_indices);
  builder_.add_push_constant_buffer_state_indices(push_constant_buffer_state_indices);
  builder_.add_uniform_buffer_state_indices(uniform_buffer_state_indices);
  builder_.add_storage_buffer_indices(storage_buffer_indices);
  builder_.add_storage_image_indices(storage_image_indices);
  builder_.add_sampler_indices(sampler_indices);
  builder_.add_image_indices(image_indices);
  builder_.add_subpass_input_indices(subpass_input_indices);
  builder_.add_sampled_image_indices(sampled_image_indices);
  builder_.add_push_constant_buffer_indices(push_constant_buffer_indices);
  builder_.add_uniform_buffer_indices(uniform_buffer_indices);
  builder_.add_stage_output_indices(stage_output_indices);
  builder_.add_stage_input_indices(stage_input_indices);
  builder_.add_constant_indices(constant_indices);
  builder_.add_name_index(name_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReflectedShader> CreateReflectedShaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t name_index = 0,
    const std::vector<uint32_t> *constant_indices = nullptr,
    const std::vector<uint32_t> *stage_input_indices = nullptr,
    const std::vector<uint32_t> *stage_output_indices = nullptr,
    const std::vector<uint32_t> *uniform_buffer_indices = nullptr,
    const std::vector<uint32_t> *push_constant_buffer_indices = nullptr,
    const std::vector<uint32_t> *sampled_image_indices = nullptr,
    const std::vector<uint32_t> *subpass_input_indices = nullptr,
    const std::vector<uint32_t> *image_indices = nullptr,
    const std::vector<uint32_t> *sampler_indices = nullptr,
    const std::vector<uint32_t> *storage_image_indices = nullptr,
    const std::vector<uint32_t> *storage_buffer_indices = nullptr,
    const std::vector<uint32_t> *uniform_buffer_state_indices = nullptr,
    const std::vector<uint32_t> *push_constant_buffer_state_indices = nullptr,
    const std::vector<uint32_t> *storage_buffer_state_indices = nullptr) {
  auto constant_indices__ = constant_indices ? _fbb.CreateVector<uint32_t>(*constant_indices) : 0;
  auto stage_input_indices__ = stage_input_indices ? _fbb.CreateVector<uint32_t>(*stage_input_indices) : 0;
  auto stage_output_indices__ = stage_output_indices ? _fbb.CreateVector<uint32_t>(*stage_output_indices) : 0;
  auto uniform_buffer_indices__ = uniform_buffer_indices ? _fbb.CreateVector<uint32_t>(*uniform_buffer_indices) : 0;
  auto push_constant_buffer_indices__ = push_constant_buffer_indices ? _fbb.CreateVector<uint32_t>(*push_constant_buffer_indices) : 0;
  auto sampled_image_indices__ = sampled_image_indices ? _fbb.CreateVector<uint32_t>(*sampled_image_indices) : 0;
  auto subpass_input_indices__ = subpass_input_indices ? _fbb.CreateVector<uint32_t>(*subpass_input_indices) : 0;
  auto image_indices__ = image_indices ? _fbb.CreateVector<uint32_t>(*image_indices) : 0;
  auto sampler_indices__ = sampler_indices ? _fbb.CreateVector<uint32_t>(*sampler_indices) : 0;
  auto storage_image_indices__ = storage_image_indices ? _fbb.CreateVector<uint32_t>(*storage_image_indices) : 0;
  auto storage_buffer_indices__ = storage_buffer_indices ? _fbb.CreateVector<uint32_t>(*storage_buffer_indices) : 0;
  auto uniform_buffer_state_indices__ = uniform_buffer_state_indices ? _fbb.CreateVector<uint32_t>(*uniform_buffer_state_indices) : 0;
  auto push_constant_buffer_state_indices__ = push_constant_buffer_state_indices ? _fbb.CreateVector<uint32_t>(*push_constant_buffer_state_indices) : 0;
  auto storage_buffer_state_indices__ = storage_buffer_state_indices ? _fbb.CreateVector<uint32_t>(*storage_buffer_state_indices) : 0;
  return cso::CreateReflectedShader(
      _fbb,
      name_index,
      constant_indices__,
      stage_input_indices__,
      stage_output_indices__,
      uniform_buffer_indices__,
      push_constant_buffer_indices__,
      sampled_image_indices__,
      subpass_input_indices__,
      image_indices__,
      sampler_indices__,
      storage_image_indices__,
      storage_buffer_indices__,
      uniform_buffer_state_indices__,
      push_constant_buffer_state_indices__,
      storage_buffer_state_indices__);
}

struct CompiledShaderCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_COMPILED_SHADER_INFOS = 6,
    VT_COMPILED_SHADERS = 8,
    VT_REFLECTED_SHADERS = 10,
    VT_REFLECTED_TYPES = 12,
    VT_REFLECTED_RESOURCES = 14,
    VT_REFLECTED_CONSTANTS = 16,
    VT_REFLECTED_RESOURCE_STATES = 18,
    VT_STRINGS = 20,
    VT_BUFFERS = 22
  };
  Version version() const {
    return static_cast<Version>(GetField<uint32_t>(VT_VERSION, 0));
  }
  bool mutate_version(Version _version) {
    return SetField<uint32_t>(VT_VERSION, static_cast<uint32_t>(_version), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>> *compiled_shader_infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>> *>(VT_COMPILED_SHADER_INFOS);
  }
  flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>> *mutable_compiled_shader_infos() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>> *>(VT_COMPILED_SHADER_INFOS);
  }
  const flatbuffers::Vector<const CompiledShader *> *compiled_shaders() const {
    return GetPointer<const flatbuffers::Vector<const CompiledShader *> *>(VT_COMPILED_SHADERS);
  }
  flatbuffers::Vector<const CompiledShader *> *mutable_compiled_shaders() {
    return GetPointer<flatbuffers::Vector<const CompiledShader *> *>(VT_COMPILED_SHADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ReflectedShader>> *reflected_shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ReflectedShader>> *>(VT_REFLECTED_SHADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ReflectedShader>> *mutable_reflected_shaders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ReflectedShader>> *>(VT_REFLECTED_SHADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ReflectedType>> *reflected_types() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ReflectedType>> *>(VT_REFLECTED_TYPES);
  }
  flatbuffers::Vector<flatbuffers::Offset<ReflectedType>> *mutable_reflected_types() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ReflectedType>> *>(VT_REFLECTED_TYPES);
  }
  const flatbuffers::Vector<const ReflectedResource *> *reflected_resources() const {
    return GetPointer<const flatbuffers::Vector<const ReflectedResource *> *>(VT_REFLECTED_RESOURCES);
  }
  flatbuffers::Vector<const ReflectedResource *> *mutable_reflected_resources() {
    return GetPointer<flatbuffers::Vector<const ReflectedResource *> *>(VT_REFLECTED_RESOURCES);
  }
  const flatbuffers::Vector<const ReflectedConstant *> *reflected_constants() const {
    return GetPointer<const flatbuffers::Vector<const ReflectedConstant *> *>(VT_REFLECTED_CONSTANTS);
  }
  flatbuffers::Vector<const ReflectedConstant *> *mutable_reflected_constants() {
    return GetPointer<flatbuffers::Vector<const ReflectedConstant *> *>(VT_REFLECTED_CONSTANTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ReflectedResourceState>> *reflected_resource_states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ReflectedResourceState>> *>(VT_REFLECTED_RESOURCE_STATES);
  }
  flatbuffers::Vector<flatbuffers::Offset<ReflectedResourceState>> *mutable_reflected_resource_states() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ReflectedResourceState>> *>(VT_REFLECTED_RESOURCE_STATES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UniqueString>> *strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UniqueString>> *>(VT_STRINGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<UniqueString>> *mutable_strings() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UniqueString>> *>(VT_STRINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UniqueBuffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UniqueBuffer>> *>(VT_BUFFERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<UniqueBuffer>> *mutable_buffers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UniqueBuffer>> *>(VT_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_COMPILED_SHADER_INFOS) &&
           verifier.VerifyVector(compiled_shader_infos()) &&
           verifier.VerifyVectorOfTables(compiled_shader_infos()) &&
           VerifyOffset(verifier, VT_COMPILED_SHADERS) &&
           verifier.VerifyVector(compiled_shaders()) &&
           VerifyOffset(verifier, VT_REFLECTED_SHADERS) &&
           verifier.VerifyVector(reflected_shaders()) &&
           verifier.VerifyVectorOfTables(reflected_shaders()) &&
           VerifyOffset(verifier, VT_REFLECTED_TYPES) &&
           verifier.VerifyVector(reflected_types()) &&
           verifier.VerifyVectorOfTables(reflected_types()) &&
           VerifyOffset(verifier, VT_REFLECTED_RESOURCES) &&
           verifier.VerifyVector(reflected_resources()) &&
           VerifyOffset(verifier, VT_REFLECTED_CONSTANTS) &&
           verifier.VerifyVector(reflected_constants()) &&
           VerifyOffset(verifier, VT_REFLECTED_RESOURCE_STATES) &&
           verifier.VerifyVector(reflected_resource_states()) &&
           verifier.VerifyVectorOfTables(reflected_resource_states()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfTables(strings()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           verifier.EndTable();
  }
};

struct CompiledShaderCollectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(Version version) {
    fbb_.AddElement<uint32_t>(CompiledShaderCollection::VT_VERSION, static_cast<uint32_t>(version), 0);
  }
  void add_compiled_shader_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>>> compiled_shader_infos) {
    fbb_.AddOffset(CompiledShaderCollection::VT_COMPILED_SHADER_INFOS, compiled_shader_infos);
  }
  void add_compiled_shaders(flatbuffers::Offset<flatbuffers::Vector<const CompiledShader *>> compiled_shaders) {
    fbb_.AddOffset(CompiledShaderCollection::VT_COMPILED_SHADERS, compiled_shaders);
  }
  void add_reflected_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReflectedShader>>> reflected_shaders) {
    fbb_.AddOffset(CompiledShaderCollection::VT_REFLECTED_SHADERS, reflected_shaders);
  }
  void add_reflected_types(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReflectedType>>> reflected_types) {
    fbb_.AddOffset(CompiledShaderCollection::VT_REFLECTED_TYPES, reflected_types);
  }
  void add_reflected_resources(flatbuffers::Offset<flatbuffers::Vector<const ReflectedResource *>> reflected_resources) {
    fbb_.AddOffset(CompiledShaderCollection::VT_REFLECTED_RESOURCES, reflected_resources);
  }
  void add_reflected_constants(flatbuffers::Offset<flatbuffers::Vector<const ReflectedConstant *>> reflected_constants) {
    fbb_.AddOffset(CompiledShaderCollection::VT_REFLECTED_CONSTANTS, reflected_constants);
  }
  void add_reflected_resource_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReflectedResourceState>>> reflected_resource_states) {
    fbb_.AddOffset(CompiledShaderCollection::VT_REFLECTED_RESOURCE_STATES, reflected_resource_states);
  }
  void add_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UniqueString>>> strings) {
    fbb_.AddOffset(CompiledShaderCollection::VT_STRINGS, strings);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UniqueBuffer>>> buffers) {
    fbb_.AddOffset(CompiledShaderCollection::VT_BUFFERS, buffers);
  }
  explicit CompiledShaderCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompiledShaderCollectionBuilder &operator=(const CompiledShaderCollectionBuilder &);
  flatbuffers::Offset<CompiledShaderCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledShaderCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledShaderCollection> CreateCompiledShaderCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    Version version = Version_Default,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderInfo>>> compiled_shader_infos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const CompiledShader *>> compiled_shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReflectedShader>>> reflected_shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReflectedType>>> reflected_types = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ReflectedResource *>> reflected_resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ReflectedConstant *>> reflected_constants = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ReflectedResourceState>>> reflected_resource_states = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UniqueString>>> strings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UniqueBuffer>>> buffers = 0) {
  CompiledShaderCollectionBuilder builder_(_fbb);
  builder_.add_buffers(buffers);
  builder_.add_strings(strings);
  builder_.add_reflected_resource_states(reflected_resource_states);
  builder_.add_reflected_constants(reflected_constants);
  builder_.add_reflected_resources(reflected_resources);
  builder_.add_reflected_types(reflected_types);
  builder_.add_reflected_shaders(reflected_shaders);
  builder_.add_compiled_shaders(compiled_shaders);
  builder_.add_compiled_shader_infos(compiled_shader_infos);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledShaderCollection> CreateCompiledShaderCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Version version = Version_Default,
    const std::vector<flatbuffers::Offset<CompiledShaderInfo>> *compiled_shader_infos = nullptr,
    const std::vector<CompiledShader> *compiled_shaders = nullptr,
    const std::vector<flatbuffers::Offset<ReflectedShader>> *reflected_shaders = nullptr,
    const std::vector<flatbuffers::Offset<ReflectedType>> *reflected_types = nullptr,
    const std::vector<ReflectedResource> *reflected_resources = nullptr,
    const std::vector<ReflectedConstant> *reflected_constants = nullptr,
    const std::vector<flatbuffers::Offset<ReflectedResourceState>> *reflected_resource_states = nullptr,
    const std::vector<flatbuffers::Offset<UniqueString>> *strings = nullptr,
    const std::vector<flatbuffers::Offset<UniqueBuffer>> *buffers = nullptr) {
  auto compiled_shader_infos__ = compiled_shader_infos ? _fbb.CreateVector<flatbuffers::Offset<CompiledShaderInfo>>(*compiled_shader_infos) : 0;
  auto compiled_shaders__ = compiled_shaders ? _fbb.CreateVectorOfStructs<CompiledShader>(*compiled_shaders) : 0;
  auto reflected_shaders__ = reflected_shaders ? _fbb.CreateVector<flatbuffers::Offset<ReflectedShader>>(*reflected_shaders) : 0;
  auto reflected_types__ = reflected_types ? _fbb.CreateVector<flatbuffers::Offset<ReflectedType>>(*reflected_types) : 0;
  auto reflected_resources__ = reflected_resources ? _fbb.CreateVectorOfStructs<ReflectedResource>(*reflected_resources) : 0;
  auto reflected_constants__ = reflected_constants ? _fbb.CreateVectorOfStructs<ReflectedConstant>(*reflected_constants) : 0;
  auto reflected_resource_states__ = reflected_resource_states ? _fbb.CreateVector<flatbuffers::Offset<ReflectedResourceState>>(*reflected_resource_states) : 0;
  auto strings__ = strings ? _fbb.CreateVector<flatbuffers::Offset<UniqueString>>(*strings) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<UniqueBuffer>>(*buffers) : 0;
  return cso::CreateCompiledShaderCollection(
      _fbb,
      version,
      compiled_shader_infos__,
      compiled_shaders__,
      reflected_shaders__,
      reflected_types__,
      reflected_resources__,
      reflected_constants__,
      reflected_resource_states__,
      strings__,
      buffers__);
}

inline const cso::CompiledShaderCollection *GetCompiledShaderCollection(const void *buf) {
  return flatbuffers::GetRoot<cso::CompiledShaderCollection>(buf);
}

inline const cso::CompiledShaderCollection *GetSizePrefixedCompiledShaderCollection(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cso::CompiledShaderCollection>(buf);
}

inline CompiledShaderCollection *GetMutableCompiledShaderCollection(void *buf) {
  return flatbuffers::GetMutableRoot<CompiledShaderCollection>(buf);
}

inline const char *CompiledShaderCollectionIdentifier() {
  return "CSOC";
}

inline bool CompiledShaderCollectionBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CompiledShaderCollectionIdentifier());
}

inline bool VerifyCompiledShaderCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cso::CompiledShaderCollection>(CompiledShaderCollectionIdentifier());
}

inline bool VerifySizePrefixedCompiledShaderCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cso::CompiledShaderCollection>(CompiledShaderCollectionIdentifier());
}

inline const char *CompiledShaderCollectionExtension() {
  return "csoc";
}

inline void FinishCompiledShaderCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cso::CompiledShaderCollection> root) {
  fbb.Finish(root, CompiledShaderCollectionIdentifier());
}

inline void FinishSizePrefixedCompiledShaderCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cso::CompiledShaderCollection> root) {
  fbb.FinishSizePrefixed(root, CompiledShaderCollectionIdentifier());
}

}  // namespace cso

#endif  // FLATBUFFERS_GENERATED_CSO_CSO_H_
